// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.28.0
// source: posts.sql

package database

import (
	"context"
	"database/sql"
	"time"

	"github.com/google/uuid"
	"github.com/lib/pq"
)

const createPost = `-- name: CreatePost :execrows
INSERT INTO posts (title, url, description, published_at, feed_id)
SELECT unnest($1::text[]),
       unnest($2::text[]),
       unnest($3::text[]),
       unnest($4::timestamp with time zone[]),
       unnest($5::bigint[])
ON CONFLICT (url) DO UPDATE
SET
    title = EXCLUDED.title,
    description = EXCLUDED.description
WHERE   posts.title IS DISTINCT FROM EXCLUDED.title 
        OR posts.description IS DISTINCT FROM EXCLUDED.description
`

type CreatePostParams struct {
	Titles       []string
	Urls         []string
	Descriptions []string
	PublishedAts []time.Time
	FeedIds      []int64
}

func (q *Queries) CreatePost(ctx context.Context, arg CreatePostParams) (int64, error) {
	result, err := q.db.ExecContext(ctx, createPost,
		pq.Array(arg.Titles),
		pq.Array(arg.Urls),
		pq.Array(arg.Descriptions),
		pq.Array(arg.PublishedAts),
		pq.Array(arg.FeedIds),
	)
	if err != nil {
		return 0, err
	}
	return result.RowsAffected()
}

const getPostsForUser_Backward = `-- name: GetPostsForUser_Backward :many
SELECT p.id, p.created_at, p.updated_at, p.title, p.url, p.description, p.published_at, p.feed_id 
FROM posts p
JOIN feed_follows f ON p.feed_id = f.feed_id
WHERE f.user_id = $1
  AND (
        NOT $3::boolean
        OR p.published_at > $4
        OR (p.published_at = $4 AND p.id > $5)
      )
ORDER BY p.published_at DESC, p.id DESC
LIMIT $2
`

type GetPostsForUser_BackwardParams struct {
	UserID     uuid.UUID
	Limit      int32
	HasCursor  bool
	CursorTime sql.NullTime
	CursorID   int32
}

func (q *Queries) GetPostsForUser_Backward(ctx context.Context, arg GetPostsForUser_BackwardParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsForUser_Backward,
		arg.UserID,
		arg.Limit,
		arg.HasCursor,
		arg.CursorTime,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.PublishedAt,
			&i.FeedID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getPostsForUser_Forward = `-- name: GetPostsForUser_Forward :many
SELECT p.id, p.created_at, p.updated_at, p.title, p.url, p.description, p.published_at, p.feed_id 
FROM posts p
JOIN feed_follows f ON p.feed_id = f.feed_id
WHERE f.user_id = $1
  AND (
        NOT $3::boolean
        OR p.published_at < $4
        OR (p.published_at = $4 AND p.id < $5)
      )
ORDER BY p.published_at DESC, p.id DESC
LIMIT $2
`

type GetPostsForUser_ForwardParams struct {
	UserID     uuid.UUID
	Limit      int32
	HasCursor  bool
	CursorTime sql.NullTime
	CursorID   int32
}

func (q *Queries) GetPostsForUser_Forward(ctx context.Context, arg GetPostsForUser_ForwardParams) ([]Post, error) {
	rows, err := q.db.QueryContext(ctx, getPostsForUser_Forward,
		arg.UserID,
		arg.Limit,
		arg.HasCursor,
		arg.CursorTime,
		arg.CursorID,
	)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []Post
	for rows.Next() {
		var i Post
		if err := rows.Scan(
			&i.ID,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.Title,
			&i.Url,
			&i.Description,
			&i.PublishedAt,
			&i.FeedID,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}
